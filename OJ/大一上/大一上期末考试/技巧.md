# 技巧

#### 1. 递归

```c++
    double fac(double num)
    {
        if (num == 0)
            return 1;
        return num * fac(num - 1);
    }
```

```c++
	int sum(int num)
    {
        if(num == 0)
            return 0;
        else
            return num + sum(num - 1);
    }
```

```c++
	int fib(int n)
    {
        if (n == 0)
            return 0;
        if (n == 1)
            return 1;
        return (fib(n-1)+fib(n-2));
    }
```



#### 2. 冒泡排序

```c++
	//由大到小
	int temp;
	for (int i = 0; i < size-1; ++i)
	{
		for (int j = 0; j < size - i; ++j)
		{
			if (a[j] < a[j+1])
			{
				temp = a[j];
				a[j] = a[j+1];
				a[j+1] = temp;
			}
		}
	}
	//第n次外层循环排好倒数前n位(只需size-1次外层循环即可)
```

```c++
	//由小到大
	int temp;
    for (int i = 0; i < num-1; ++i)
    {
        for (int j = num; j > i; j--)
        {
            if (a[j] > a[j-1])
            {
                temp = a[j];
                a[j] = a[j-1];
                a[j-1] = temp;
            }
        }
    }
```

#### 3. 搜索

```c++
//传递判断
	double temp3;
	bool transitive;
	for (int i = 0; i < num; ++i)
	{
		temp1 = relation[i][0];
		temp2 = relation[i][1];

		for (int p = 0; p <num ; ++p)
		{
			if (relation[p][0] == temp2)
			{
				temp3 = relation[p][1];
				for (int q = 0; q < num; ++q)
				{
					if (relation[q][0] == temp1 && relation[q][1] == temp3)
					{
						transitive = true;
						break;
					}
					else
						transitive = false;
				}

				if (transitive == true)
					break;
			}
		}
		if (transitive == false)
			break;
	}
	if (transitive == true)
		
		cout << "transitive" << endl;
```

